#%%
'''
Fit Bayesian models to the RNN-AC simulated data
'''

import matplotlib.pyplot as plt
import numpy as np
#import pymc as pm
#import pytensor
#import pytensor.tensor as pt
import scipy
import scipy.stats as stats
import utils


#%% 
#minimize likelihood function to get MLE estimates of parameters (no fitting)

class BayesianModel: 
    def __init__(self, states, model_type = 'changepoint'):
        self.states = states
        self.model_type = model_type
        self.prediction_error, self.update, self.learning_rate, self.true_state, self.predicted_state,self.hazard_distance, self.hazard_trials = utils.extract_states(states)
    
    def run_mle(self):
        true_switch = .2 #changepoint rate
        true_noise = .125 #heli to bag noise 
        #data values
        true_ll = self.get_llik([true_switch, true_noise], *(self.predicted_state, self.prediction_error)) #given true params
        #true MLE values
        x0 = [true_switch, true_noise]
        result = scipy.optimize.minimize(self.get_llik, x0, args=(self.predicted_state, self.prediction_error), method='BFGS')
        print(f"MLE: alpha = {result.x[0]:.2f} (true value = {true_noise})")
        print(f"MLE: beta = {result.x[1]:.2f} (true value = {true_switch})")
        print(f"True Log-Likelihood: {true_ll:.4f}")
        print(f"Difference from result: {true_ll - result.fun:.4f}")

    def get_llik(self, x, *args, model_name = 'normative'):
        #take args from minimizer
        Ω, τ = x
        actions, δ = args
        #initialize values
        logp_actions = np.zeros(len(actions))  
        #run loop
        for t in range(len(actions)):
            #run through model
            logp_action = self.flexible_normative_model(Ω = Ω,
                                                        τ = τ, 
                                                        δ = δ[t], 
                                                        task_name = 'changepoint')

            #store necessary data 
            logp_actions[t] = logp_action
            #update states for next trial
            

        return -np.sum(logp_actions[1:]) 


    def flexible_normative_model(
        self,
        #params
        Ω: float = .20,   #Ω = changepoint probability
        τ: float = .125,  #τ = relative uncertainty
        UU: float = .001,     #UU = uncertainty underestimation 
        σ_motor: float = .001, 
        σ_LR: float = .90, 
        #priors 
        H: float = .2,      #H = changepoint or oddball prob dependening on the condition
        LW: float = .001,      #LW = likelihood weight
        σ: float = .90,      #σ = total var on predictive dist
        #data
        δ: float = .5,       #δ = prediction error
        participant_update: float = 50,  #participant update
        task_name: str = "change_point"): 


        #eq 4 - needs hardset priors in
        U_val = stats.uniform.pdf(δ, 0, 300) ** LW
        N_val = stats.norm.pdf(δ, 0, σ) ** LW
        Ω = utils.calculate_omega(H, U_val, N_val)
        #eq 5 - in oddball, relative uncertainty requires drift rate D (?)
        τ = utils.calculate_tau(τ, UU)

        if task_name == 'changepoint':
            #eq 2
            alpha = utils.calculate_alpha_changepoint(Ω, τ)
        elif task_name == 'oddball':
            #eq 3
            alpha = utils.calculate_alpha_oddball(τ, Ω)
        else:
            raise ValueError("model_type must be either 'changepoint' or 'oddball'")   

        #eq 1
        normative_update = utils.calculate_normative_update(alpha, δ)
        
        #eq 7, variability of update
        σ_update = utils.calculate_sigma_update(σ_motor, normative_update, σ_LR)

        #eq 6
        L_normative = utils.calculate_L_normative(participant_update, normative_update, σ_update)

        #make log likelihood
        ll = -np.log(L_normative)

        return ll


#%%
#run 
if __name__ == "__main__":
    states = np.load('data/pt_rnn_context/env_data.npy') #[trials, bucket_position, bag_position, helicopter_position]
    model = BayesianModel(states, model_type = 'changepoint')
    model.run_mle()














#%%
#all formulas

# #eq 1
# normative_update[t] = α[t] * δ[t]
# #eq 2
# CP_LR[t] = Ω + τ - (Ω  * τ)
# #eq 3
# OB_LR[t] = τ - (τ * Ω )
# #eq 4 - needs hardset priors in
# Ω = (H * U_val ) / (
#     (H * U_val + (1 - H) * N_val)
# )
# U_val = stats.uniform.pdf(δ, 0, 300) ** LW
# N_val = stats.norm.pdf(δ, 0, σ[t]) ** LW
# #eq 5 - in oddball, relative uncertainty requires drift rate D (?)
# τ = τ / UU
# #eq 6
# L_normative = stats.norm.pdf(participant_update[t], loc=normative_update[t], scale=σ_update)
# #eq 7, variability of update
# σ_update = σ_motor + normative_update(t) * σ_LR

# #make log likelihood
# ll = -log(L_normative)